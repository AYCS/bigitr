This tool copies content between Git and CVS repositories in an
asynchronous and asymmetric fashion.

The flow is conceptually similar to Git's flow for synchronizing with
a remote repository.  For example, the local master branch is pushed
to the master branch on the origin repository, pulled from the remote
origin master branch to the local origin/master reference, and then
the local origin/master reference is merged onto the local master
branch.  Similarly, the Git master branch might be exported to a CVS
branch current-dev, which is then imported into a Git branch named
cvs-current-dev, which then might be merged back into the Git master
branch.

* This tool commits to CVS and pushes to remote Git repositories.
  Do backups, and test configuration initially with throwaway
  copies of CVS and Git repositories before you put this tool into
  production use.

* It exports branches in Git into branches in CVS.

* It will not touch the CVS trunk (at least at this time).

* It will not synchronize only parts of a CVS sub/module.  It is
  all or nothing: for any particular sub/module, any files not in
  the Git branch being exported to CVS will be DELETED from that
  branch in that CVS sub/module.

* It imports branches from CVS into special import branches (with names
  starting with "cvs-" in Git.

* After committing to branches (not including fast-forwarding the
  export- branches), it will automatically attempt to merge changes
  into other explicitly-specified branches.  If any merges are
  successful, those merges themselves may trigger other merge
  operations.

* Branches in the Git repositories with names starting with "cvs-"
  and "export-" are reserved to be written only by this tool.
  These branches are pushed to the origin repository so that local
  state does not need to be maintained.  This means that multiple
  users can run this tool using the same repository configuration
  but different application configuration (local directories).
  However, no locking is attempted, so if two users run it at the
  same time, the results are undefined.

* It is reasonable to configure no automatic merging at all.  Be,
  aware that if you have configured the Git "master" branch to be
  exported to an existing CVS branch, then you should populate the
  Git "master" branch before exporting.  In most cases, a master
  branch should be a merge target at least for the initial import,
  even if the merge target is later disabled in favor of merging
  changes manually.

* An attempt to export an empty Git branch to a CVS branch will
  raise an exception rather than deleting all the files on the CVS
  branch.  If you really want to delete all the files on the CVS
  branch, do it by hand.

* Files in CVS ignored by .gitignore will not be committed to the
  corresponding Git branches, and if those .gitignore changes are
  represented on a branch being exported from Git into CVS, those
  files will be deleted from the CVS branch when the Git branch
  is exported to CVS.

* Files with names starting with ".git" will not be commited to CVS;
  that file namespace is reserved for Git even for Git metadata file
  types that have not yet been created as of the time that this tool
  was written.

* It is recommended that only Git metadata files with names starting
  with .git be included in "skeletons" used to populate empty
  branches, because the protections against accidentally exporting
  empty branches to CVS apply only to Git metadata files.

* There are pre-commit and post-commit hooks for both Git and CVS,
  in order to implement normalization rules, notification, and so
  forth.  These commands are run with the current working directory
  set to the Git working directory or CVS checkout.  These can be
  specified for all repositories or for a single repository, and
  for all branches or only individual branches.  The arguments are
  included in the configuration using shell syntax; no extra
  arguments are added.

There are two kinds of configuration files.
* Application configuration: general behavior
* Repository configuration: specific to a Git repository

This tool depends on precise behavior of Git and CVS, and on the "-i"
option to sed.  The behavior of this tool should be validated after
ANY update to any of the programs which it calls: git, cvs, and sed,
as well as after any other update that might affect them (libraries,
system language configuration, etc.).  A test suite is provided to
help validate this behavior.  If you discover failures not exposed by
the test suite, please augment the test suite.  In particular,
additional functional tests or story tests would be appropriate.
This tool automates only (part of) the PROCESS of synchronization
between Git and CVS branches.  It does not automate any MONITORING
of the results.  Do not relax monitoring because you are using it.
For example, if you have changemail notification on CVS, do not disable
it for branches that are developed in Git and pushed to CVS; use that
changemail to confirm that the synchronization process has worked.

This tool also assumes essentially unlimited argument length, as it
passes arbitrarily many file names on the command line.  This limits
it to working on relatively recent Linux kernels (2.6.23 and later)
for large repositories.  At least Python 2.5 is required (due to the
use of "with").
